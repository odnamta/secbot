/**
 * Enhanced WAF fingerprinting â€” identifies specific WAF products from response
 * characteristics and maps them to recommended bypass techniques.
 *
 * This extends the basic WAF detection in recon.ts with more granular fingerprinting
 * and actionable bypass technique recommendations.
 *
 * For authorized security testing only.
 */

import type { InterceptedResponse, Confidence } from './types.js';

export interface WafFingerprint {
  /** Identified WAF product name, or 'Unknown' */
  wafName: string;
  /** Confidence level of the fingerprint */
  confidence: Confidence;
  /** Evidence that led to the identification */
  evidence: string[];
  /** Recommended bypass techniques for this specific WAF */
  recommendedTechniques: string[];
}

interface WafSignature {
  name: string;
  /** Check response headers for these patterns */
  headerPatterns: { header: string; pattern: RegExp }[];
  /** Check response body for these patterns */
  bodyPatterns: RegExp[];
  /** Check for specific status codes combined with body/header signals */
  statusCodes?: number[];
  /** Recommended bypass techniques specific to this WAF */
  techniques: string[];
}

const WAF_SIGNATURES: WafSignature[] = [
  {
    name: 'Cloudflare',
    headerPatterns: [
      { header: 'cf-ray', pattern: /^[0-9a-f]+-[A-Z]{3}$/i },
      { header: 'server', pattern: /^cloudflare$/i },
      { header: 'set-cookie', pattern: /__cfduid/i },
      { header: 'cf-cache-status', pattern: /.+/ },
    ],
    bodyPatterns: [
      /Attention Required!/i,
      /Cloudflare Ray ID/i,
      /cf-error-details/i,
      /cloudflare\.com\/5xx-error-landing/i,
    ],
    statusCodes: [403, 503],
    techniques: [
      'unicode-encoding',
      'double-url-encoding',
      'case-randomization',
      'null-byte-insertion',
      'chunked-transfer-encoding',
      'header-manipulation',
    ],
  },
  {
    name: 'AWS WAF',
    headerPatterns: [
      { header: 'x-amzn-requestid', pattern: /.+/ },
      { header: 'x-amzn-waf-action', pattern: /.+/ },
      { header: 'x-amzn-trace-id', pattern: /Root=/ },
    ],
    bodyPatterns: [
      /Request blocked/i,
      /This request has been blocked/i,
      /AWS WAF/i,
      /x-amzn-waf/i,
    ],
    statusCodes: [403],
    techniques: [
      'url-encoding',
      'unicode-encoding',
      'sql-comment-obfuscation',
      'http-parameter-pollution',
      'content-type-manipulation',
      'json-body-injection',
    ],
  },
  {
    name: 'ModSecurity',
    headerPatterns: [
      { header: 'server', pattern: /mod_security|NOYB/i },
      { header: 'x-mod-security', pattern: /.+/ },
    ],
    bodyPatterns: [
      /mod_security/i,
      /NOYB/,
      /This error was generated by Mod_Security/i,
      /ModSecurity Action/i,
      /ModSecurity: Access denied/i,
    ],
    statusCodes: [403, 406],
    techniques: [
      'sql-comment-obfuscation',
      'case-randomization',
      'unicode-encoding',
      'mixed-encoding',
      'http-parameter-pollution',
      'polyglot-payloads',
    ],
  },
  {
    name: 'Sucuri',
    headerPatterns: [
      { header: 'x-sucuri-id', pattern: /.+/ },
      { header: 'x-sucuri-cache', pattern: /.+/ },
      { header: 'server', pattern: /Sucuri/i },
      { header: 'set-cookie', pattern: /sucuri[-_]/i },
    ],
    bodyPatterns: [
      /Access Denied - Sucuri Website Firewall/i,
      /Sucuri WebSite Firewall/i,
      /sucuri\.net\/privacy/i,
      /cloudproxy@sucuri\.net/i,
    ],
    statusCodes: [403],
    techniques: [
      'double-url-encoding',
      'unicode-encoding',
      'html-entity-encoding',
      'case-randomization',
      'http-parameter-pollution',
    ],
  },
  {
    name: 'Akamai',
    headerPatterns: [
      { header: 'server', pattern: /AkamaiGHost/i },
      { header: 'x-akamai-transformed', pattern: /.+/ },
      { header: 'akamai-grn', pattern: /.+/ },
      { header: 'x-akamai-request-id', pattern: /.+/ },
    ],
    bodyPatterns: [
      /AkamaiGHost/i,
      /Access Denied.*akamai/i,
      /Reference\s*#\d+\.\w+\.\d+/i, // Akamai reference ID format
    ],
    statusCodes: [403],
    techniques: [
      'double-url-encoding',
      'html-entity-encoding',
      'sql-comment-obfuscation',
      'content-type-manipulation',
      'chunked-transfer-encoding',
      'json-body-injection',
    ],
  },
  {
    name: 'Imperva',
    headerPatterns: [
      { header: 'x-iinfo', pattern: /.+/ },
      { header: 'x-cdn', pattern: /Incapsula/i },
      { header: 'set-cookie', pattern: /incap_ses_|visid_incap_/i },
    ],
    bodyPatterns: [
      /Incapsula incident ID/i,
      /Powered by Incapsula/i,
      /Request unsuccessful\. Incapsula/i,
      /_Incapsula_Resource/i,
    ],
    statusCodes: [403],
    techniques: [
      'unicode-encoding',
      'double-url-encoding',
      'mixed-encoding',
      'http-parameter-pollution',
      'polyglot-payloads',
      'content-type-manipulation',
    ],
  },
  {
    name: 'F5 BIG-IP ASM',
    headerPatterns: [
      { header: 'server', pattern: /BIG-IP|BigIP/i },
      { header: 'set-cookie', pattern: /TS[0-9a-f]{6,}=/i },
      { header: 'x-wa-info', pattern: /.+/ },
    ],
    bodyPatterns: [
      /The requested URL was rejected/i,
      /support ID is/i,
      /BIG-IP/i,
    ],
    statusCodes: [403],
    techniques: [
      'sql-comment-obfuscation',
      'unicode-encoding',
      'double-url-encoding',
      'case-randomization',
      'http-parameter-pollution',
    ],
  },
];

/**
 * Fingerprint a WAF from a collection of intercepted HTTP responses.
 *
 * Analyzes response headers, body content, and status codes against
 * known WAF signatures to identify the specific WAF product in use.
 *
 * @param responses - Array of intercepted HTTP responses to analyze
 * @returns WafFingerprint with identified WAF, confidence, evidence, and recommended techniques
 */
export function fingerprintWaf(responses: InterceptedResponse[]): WafFingerprint {
  const signatureScores: Map<string, { score: number; evidence: string[] }> = new Map();

  for (const sig of WAF_SIGNATURES) {
    signatureScores.set(sig.name, { score: 0, evidence: [] });
  }

  for (const response of responses) {
    for (const sig of WAF_SIGNATURES) {
      const entry = signatureScores.get(sig.name)!;

      // Check header patterns
      for (const { header, pattern } of sig.headerPatterns) {
        const headerValue = response.headers[header] || response.headers[header.toLowerCase()];
        if (headerValue && pattern.test(headerValue)) {
          entry.score += 2;
          entry.evidence.push(`Header "${header}: ${headerValue}" matches ${sig.name} pattern`);
        }
      }

      // Check body patterns
      if (response.body) {
        for (const pattern of sig.bodyPatterns) {
          if (pattern.test(response.body)) {
            entry.score += 3; // Body patterns are stronger signals
            entry.evidence.push(`Response body matches ${sig.name} pattern: ${pattern.source}`);
          }
        }
      }

      // Check status codes (only adds score if combined with other evidence)
      if (sig.statusCodes?.includes(response.status) && entry.score > 0) {
        entry.score += 1;
        entry.evidence.push(`Status code ${response.status} consistent with ${sig.name} blocking`);
      }
    }
  }

  // Find the WAF with the highest score
  let bestMatch: { name: string; score: number; evidence: string[] } | null = null;
  for (const [name, data] of signatureScores) {
    if (data.score > 0 && (!bestMatch || data.score > bestMatch.score)) {
      bestMatch = { name, ...data };
    }
  }

  if (!bestMatch) {
    return {
      wafName: 'Unknown',
      confidence: 'low',
      evidence: [],
      recommendedTechniques: [
        'url-encoding',
        'double-url-encoding',
        'case-randomization',
        'http-parameter-pollution',
      ],
    };
  }

  // Determine confidence based on score
  let confidence: Confidence;
  if (bestMatch.score >= 5) {
    confidence = 'high';
  } else if (bestMatch.score >= 3) {
    confidence = 'medium';
  } else {
    confidence = 'low';
  }

  // Deduplicate evidence
  const uniqueEvidence = [...new Set(bestMatch.evidence)];

  // Get the techniques for this WAF
  const sig = WAF_SIGNATURES.find((s) => s.name === bestMatch!.name);
  const techniques = sig?.techniques ?? [];

  return {
    wafName: bestMatch.name,
    confidence,
    evidence: uniqueEvidence,
    recommendedTechniques: techniques,
  };
}

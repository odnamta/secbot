import { describe, it, expect } from 'vitest';
import { fingerprintWaf, type WafFingerprint } from '../../src/scanner/waf-fingerprint.js';
import type { InterceptedResponse } from '../../src/scanner/types.js';

/** Helper to build a minimal InterceptedResponse */
function makeResponse(overrides: Partial<InterceptedResponse> = {}): InterceptedResponse {
  return {
    url: 'https://example.com/',
    status: 200,
    headers: {},
    body: '',
    ...overrides,
  };
}

describe('WAF Fingerprinting', () => {
  describe('Cloudflare detection', () => {
    it('detects Cloudflare via cf-ray header', () => {
      const responses = [
        makeResponse({
          headers: { 'cf-ray': '8abc123def-SJC', 'server': 'cloudflare' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Cloudflare');
      expect(result.confidence).not.toBe('low');
      expect(result.evidence.length).toBeGreaterThan(0);
    });

    it('detects Cloudflare via __cfduid cookie in set-cookie', () => {
      const responses = [
        makeResponse({
          headers: { 'set-cookie': '__cfduid=abc123; path=/; HttpOnly' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Cloudflare');
    });

    it('detects Cloudflare via body content', () => {
      const responses = [
        makeResponse({
          status: 403,
          headers: { 'server': 'cloudflare' },
          body: '<html><title>Attention Required! | Cloudflare</title><p>Cloudflare Ray ID: 8abc123def</p></html>',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Cloudflare');
      expect(result.confidence).toBe('high');
    });

    it('recommends appropriate bypass techniques for Cloudflare', () => {
      const responses = [
        makeResponse({
          headers: { 'cf-ray': '8abc123def-SJC', 'server': 'cloudflare' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.recommendedTechniques).toContain('unicode-encoding');
      expect(result.recommendedTechniques).toContain('double-url-encoding');
    });
  });

  describe('AWS WAF detection', () => {
    it('detects AWS WAF via x-amzn-requestid header', () => {
      const responses = [
        makeResponse({
          headers: { 'x-amzn-requestid': 'abc-123-def-456' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('AWS WAF');
    });

    it('detects AWS WAF via 403 + body content', () => {
      const responses = [
        makeResponse({
          status: 403,
          headers: { 'x-amzn-requestid': 'abc-123' },
          body: 'Request blocked by AWS WAF',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('AWS WAF');
      expect(result.confidence).toBe('high');
    });

    it('recommends appropriate bypass techniques for AWS WAF', () => {
      const responses = [
        makeResponse({
          headers: { 'x-amzn-requestid': 'abc-123' },
          body: 'Request blocked',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.recommendedTechniques).toContain('http-parameter-pollution');
      expect(result.recommendedTechniques).toContain('sql-comment-obfuscation');
    });
  });

  describe('ModSecurity detection', () => {
    it('detects ModSecurity via server header', () => {
      const responses = [
        makeResponse({
          headers: { 'server': 'Apache/2.4 mod_security/2.9.3' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('ModSecurity');
    });

    it('detects ModSecurity via NOYB in server header', () => {
      const responses = [
        makeResponse({
          headers: { 'server': 'NOYB' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('ModSecurity');
    });

    it('detects ModSecurity via body content', () => {
      const responses = [
        makeResponse({
          status: 403,
          headers: { 'server': 'NOYB' },
          body: 'This error was generated by Mod_Security. Access denied.',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('ModSecurity');
      expect(result.confidence).toBe('high');
    });

    it('recommends polyglot-payloads for ModSecurity', () => {
      const responses = [
        makeResponse({
          headers: { 'server': 'NOYB' },
          body: 'ModSecurity Action',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.recommendedTechniques).toContain('polyglot-payloads');
    });
  });

  describe('Sucuri detection', () => {
    it('detects Sucuri via x-sucuri-id header', () => {
      const responses = [
        makeResponse({
          headers: { 'x-sucuri-id': '12345' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Sucuri');
    });

    it('detects Sucuri via set-cookie with sucuri prefix', () => {
      const responses = [
        makeResponse({
          headers: { 'set-cookie': 'sucuri-s=abc123; path=/' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Sucuri');
    });

    it('detects Sucuri via body content', () => {
      const responses = [
        makeResponse({
          status: 403,
          headers: { 'x-sucuri-id': '12345' },
          body: 'Access Denied - Sucuri Website Firewall. If you think this is an error contact cloudproxy@sucuri.net',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Sucuri');
      expect(result.confidence).toBe('high');
    });
  });

  describe('Akamai detection', () => {
    it('detects Akamai via server header', () => {
      const responses = [
        makeResponse({
          headers: { 'server': 'AkamaiGHost' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Akamai');
    });

    it('detects Akamai via x-akamai-transformed header', () => {
      const responses = [
        makeResponse({
          headers: { 'x-akamai-transformed': '9 12345 0 pmb=mRUM,2' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Akamai');
    });

    it('detects Akamai via akamai-grn header', () => {
      const responses = [
        makeResponse({
          headers: { 'akamai-grn': '0.abc.123.456' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Akamai');
    });

    it('recommends chunked-transfer-encoding for Akamai', () => {
      const responses = [
        makeResponse({
          headers: { 'server': 'AkamaiGHost' },
          body: 'Access Denied by akamai rules',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.recommendedTechniques).toContain('chunked-transfer-encoding');
    });
  });

  describe('Imperva detection', () => {
    it('detects Imperva via x-iinfo header', () => {
      const responses = [
        makeResponse({
          headers: { 'x-iinfo': '10-12345-0 0NNN RT' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Imperva');
    });

    it('detects Imperva via Incapsula cookie', () => {
      const responses = [
        makeResponse({
          headers: { 'set-cookie': 'incap_ses_12345=abc; path=/' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Imperva');
    });

    it('detects Imperva via x-cdn Incapsula header', () => {
      const responses = [
        makeResponse({
          headers: { 'x-cdn': 'Incapsula' },
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Imperva');
    });

    it('detects Imperva via body content', () => {
      const responses = [
        makeResponse({
          status: 403,
          headers: { 'x-iinfo': '10-12345' },
          body: 'Incapsula incident ID: 12345. Powered by Incapsula.',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Imperva');
      expect(result.confidence).toBe('high');
    });
  });

  describe('Unknown / no WAF', () => {
    it('returns Unknown when no WAF signatures match', () => {
      const responses = [
        makeResponse({
          headers: { 'server': 'nginx', 'content-type': 'text/html' },
          body: '<html>Hello World</html>',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Unknown');
      expect(result.confidence).toBe('low');
    });

    it('returns Unknown for empty responses array', () => {
      const result = fingerprintWaf([]);
      expect(result.wafName).toBe('Unknown');
      expect(result.confidence).toBe('low');
    });

    it('provides generic bypass techniques when WAF is unknown', () => {
      const result = fingerprintWaf([]);
      expect(result.recommendedTechniques.length).toBeGreaterThan(0);
      expect(result.recommendedTechniques).toContain('url-encoding');
      expect(result.recommendedTechniques).toContain('http-parameter-pollution');
    });
  });

  describe('general behavior', () => {
    it('always returns a valid WafFingerprint shape', () => {
      const testCases: InterceptedResponse[][] = [
        [],
        [makeResponse()],
        [makeResponse({ headers: { 'cf-ray': '123-ABC' } })],
      ];

      for (const responses of testCases) {
        const result = fingerprintWaf(responses);
        expect(result).toHaveProperty('wafName');
        expect(result).toHaveProperty('confidence');
        expect(result).toHaveProperty('evidence');
        expect(result).toHaveProperty('recommendedTechniques');
        expect(typeof result.wafName).toBe('string');
        expect(['high', 'medium', 'low']).toContain(result.confidence);
        expect(Array.isArray(result.evidence)).toBe(true);
        expect(Array.isArray(result.recommendedTechniques)).toBe(true);
      }
    });

    it('handles multiple responses accumulating evidence', () => {
      const responses = [
        makeResponse({ headers: { 'cf-ray': '8abc-SJC' } }),
        makeResponse({
          status: 403,
          headers: { 'server': 'cloudflare' },
          body: 'Attention Required! Cloudflare',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Cloudflare');
      expect(result.confidence).toBe('high');
      // Should have multiple pieces of evidence
      expect(result.evidence.length).toBeGreaterThan(1);
    });

    it('picks the highest-scoring WAF when multiple match partially', () => {
      // Response has a weak Cloudflare signal and a strong Akamai signal
      const responses = [
        makeResponse({
          headers: {
            'server': 'AkamaiGHost',
            'x-akamai-transformed': '9 123',
            'akamai-grn': '0.abc',
          },
          body: 'AkamaiGHost blocked this request',
        }),
      ];
      const result = fingerprintWaf(responses);
      expect(result.wafName).toBe('Akamai');
    });

    it('deduplicates evidence entries', () => {
      // Same response repeated â€” evidence from identical header matches should be deduped
      const response = makeResponse({
        headers: { 'cf-ray': '8abc-SJC', 'server': 'cloudflare' },
      });
      const responses = [response, response, response];
      const result = fingerprintWaf(responses);
      const uniqueEvidence = new Set(result.evidence);
      expect(result.evidence.length).toBe(uniqueEvidence.size);
    });
  });
});
